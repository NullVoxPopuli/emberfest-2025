{"version":3,"file":"index-DLSqniqQ.js","sources":["../../node_modules/.pnpm/decorator-transforms@2.3.0_@babel+core@7.28.3/node_modules/decorator-transforms/dist/global-id-BrhFC90G.js","../../node_modules/.pnpm/decorator-transforms@2.3.0_@babel+core@7.28.3/node_modules/decorator-transforms/dist/index.js"],"sourcesContent":["const globalId = `dt7948`;\nexport {\n  globalId as g\n};\n//# sourceMappingURL=global-id-BrhFC90G.js.map\n","import { g as globalId } from \"./global-id-BrhFC90G.js\";\nvar src = {};\nObject.defineProperty(src, \"__esModule\", { value: true });\nvar ImportUtil_1 = src.ImportUtil = void 0;\nclass ImportUtil {\n  constructor(babel, program) {\n    this.babel = babel;\n    this.program = program;\n    this.t = babel.types;\n  }\n  // remove one imported binding. If this is the last thing imported from the\n  // given moduleSpecifier, the whole statement will also be removed.\n  removeImport(moduleSpecifier, exportedName) {\n    for (let topLevelPath of this.program.get(\"body\")) {\n      if (!matchModule(topLevelPath, moduleSpecifier)) {\n        continue;\n      }\n      let importSpecifierPath = topLevelPath.get(\"specifiers\").find((specifierPath) => matchSpecifier(specifierPath, exportedName));\n      if (importSpecifierPath) {\n        if (topLevelPath.node.specifiers.length === 1) {\n          topLevelPath.remove();\n        } else {\n          importSpecifierPath.remove();\n        }\n      }\n    }\n  }\n  // remove all imports from the given moduleSpecifier\n  removeAllImports(moduleSpecifier) {\n    for (let topLevelPath of this.program.get(\"body\")) {\n      if (matchModule(topLevelPath, moduleSpecifier)) {\n        topLevelPath.remove();\n      }\n    }\n  }\n  // Import the given value (if needed) and return an Identifier representing\n  // it.\n  //\n  // This method is trickier to use safely than our higher-level methods\n  // (`insertAfter`, `insertBefore`, `replaceWith`, `mutate`) because after you\n  // insert the identifier into the AST, it's up to you to ensure that babel's\n  // scope system is aware of the new reference. The other methods do that for\n  // you automatically.\n  import(target, moduleSpecifier, exportedName, nameHint) {\n    return this.unreferencedImport(target, moduleSpecifier, exportedName, desiredName(nameHint, exportedName, defaultNameHint(target)));\n  }\n  // Import the given value (if needed) and return an Identifier representing\n  // it.\n  unreferencedImport(target, moduleSpecifier, exportedName, preferredName) {\n    var _a;\n    let isNamespaceImport = exportedName === \"*\";\n    let isDefaultImport = exportedName === \"default\";\n    let isNamedImport = !isDefaultImport && !isNamespaceImport;\n    let declaration = this.findImportFrom(moduleSpecifier);\n    let hasNamespaceSpecifier = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === \"ImportNamespaceSpecifier\");\n    let hasNamedSpecifiers = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === \"ImportSpecifier\");\n    let cannotUseExistingDeclaration = hasNamedSpecifiers && isNamespaceImport || hasNamespaceSpecifier && isNamedImport || hasNamespaceSpecifier && isNamespaceImport;\n    if (!cannotUseExistingDeclaration && declaration) {\n      let specifier = declaration.get(\"specifiers\").find((spec) => matchSpecifier(spec, exportedName));\n      if (specifier && ((_a = target.scope.getBinding(specifier.node.local.name)) === null || _a === void 0 ? void 0 : _a.kind) === \"module\") {\n        return this.t.identifier(specifier.node.local.name);\n      } else {\n        return this.addSpecifier(target, declaration, exportedName, preferredName);\n      }\n    } else {\n      let declaration2 = this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));\n      return this.addSpecifier(target, declaration2, exportedName, preferredName);\n    }\n  }\n  importForSideEffect(moduleSpecifier) {\n    let declaration = this.findImportFrom(moduleSpecifier);\n    if (!declaration) {\n      this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));\n    }\n  }\n  replaceWith(target, fn) {\n    return this.mutate((i) => {\n      target.replaceWith(fn(i));\n      return target;\n    }, defaultNameHint(target));\n  }\n  insertAfter(target, fn) {\n    return this.mutate((i) => target.insertAfter(fn(i))[0], defaultNameHint(target));\n  }\n  insertBefore(target, fn) {\n    return this.mutate((i) => target.insertBefore(fn(i))[0], defaultNameHint(target));\n  }\n  // Low-level method for when you don't want to use our higher-level methods\n  // (replaceWith, insertBefore, insertAfter)\n  mutate(fn, defaultNameHint2) {\n    let symbols = /* @__PURE__ */ new Map();\n    const importer = {\n      import: (moduleSpecifier, exportedName, nameHint) => {\n        let identifier = this.t.identifier(\"__babel_import_util_placeholder__\");\n        symbols.set(identifier, { moduleSpecifier, exportedName, nameHint });\n        return identifier;\n      }\n    };\n    const updateReference = (path) => {\n      if (!path.isIdentifier()) {\n        return;\n      }\n      let hit = symbols.get(path.node);\n      if (hit) {\n        let newIdentifier = this.unreferencedImport(path, hit.moduleSpecifier, hit.exportedName, desiredName(hit.nameHint, hit.exportedName, defaultNameHint2));\n        path.replaceWith(newIdentifier);\n        let binding = path.scope.getBinding(newIdentifier.name);\n        if (!binding) {\n          throw new Error(`bug: this is supposed to never happen`);\n        }\n        binding.reference(path);\n      }\n    };\n    let result = fn(importer);\n    updateReference(result);\n    this.babel.traverse(result.node, {\n      ReferencedIdentifier: (path) => {\n        updateReference(path);\n      }\n    }, result.scope, {}, result);\n    return result;\n  }\n  addSpecifier(target, declaration, exportedName, preferredName) {\n    let local = this.t.identifier(unusedNameLike(target, preferredName));\n    let specifier = this.buildSpecifier(exportedName, local);\n    let added;\n    if (specifier.type === \"ImportDefaultSpecifier\") {\n      declaration.node.specifiers.unshift(specifier);\n      added = declaration.get(`specifiers.0`);\n    } else {\n      declaration.node.specifiers.push(specifier);\n      added = declaration.get(`specifiers.${declaration.node.specifiers.length - 1}`);\n    }\n    declaration.scope.registerBinding(\"module\", added);\n    return local;\n  }\n  buildSpecifier(exportedName, localName) {\n    switch (exportedName) {\n      case \"default\":\n        return this.t.importDefaultSpecifier(localName);\n      case \"*\":\n        return this.t.importNamespaceSpecifier(localName);\n      default:\n        return this.t.importSpecifier(localName, this.t.identifier(exportedName));\n    }\n  }\n  findImportFrom(moduleSpecifier) {\n    for (let path of this.program.get(\"body\")) {\n      if (path.isImportDeclaration() && path.node.source.value === moduleSpecifier && path.node.importKind !== \"type\") {\n        return path;\n      }\n    }\n    return void 0;\n  }\n  insertAfterExistingImports(statement) {\n    let lastIndex;\n    for (let [index, node] of this.program.node.body.entries()) {\n      if (node.type === \"ImportDeclaration\") {\n        lastIndex = index;\n      }\n    }\n    if (lastIndex == null) {\n      this.program.node.body.unshift(statement);\n      return this.program.get(\"body.0\");\n    } else {\n      this.program.node.body.splice(lastIndex + 1, 0, statement);\n      return this.program.get(`body.${lastIndex + 1}`);\n    }\n  }\n}\nImportUtil_1 = src.ImportUtil = ImportUtil;\nfunction unusedNameLike(path, name2) {\n  let candidate = name2;\n  let counter = 0;\n  while (path.scope.hasBinding(candidate)) {\n    candidate = `${name2}${counter++}`;\n  }\n  return candidate;\n}\nfunction name(node) {\n  if (node.type === \"StringLiteral\") {\n    return node.value;\n  } else {\n    return node.name;\n  }\n}\nfunction desiredName(nameHint, exportedName, defaultNameHint2) {\n  if (nameHint) {\n    let cleaned = nameHint.replace(/[^a-zA-Z_]([a-z])/g, (_m, letter) => letter.toUpperCase());\n    cleaned = cleaned.replace(/[^a-zA-Z_]/g, \"\");\n    return cleaned;\n  }\n  if (exportedName === \"default\" || exportedName === \"*\") {\n    return defaultNameHint2 !== null && defaultNameHint2 !== void 0 ? defaultNameHint2 : \"a\";\n  } else {\n    return exportedName;\n  }\n}\nfunction defaultNameHint(target) {\n  if (target === null || target === void 0 ? void 0 : target.isIdentifier()) {\n    return target.node.name;\n  } else if (target) {\n    return target.scope.generateUidIdentifierBasedOnNode(target.node).name;\n  } else {\n    return void 0;\n  }\n}\nfunction matchSpecifier(spec, exportedName) {\n  switch (exportedName) {\n    case \"default\":\n      return spec.isImportDefaultSpecifier();\n    case \"*\":\n      return spec.isImportNamespaceSpecifier();\n    default:\n      return spec.isImportSpecifier() && name(spec.node.imported) === exportedName;\n  }\n}\nfunction matchModule(path, moduleSpecifier) {\n  return path.isImportDeclaration() && path.get(\"source\").node.value === moduleSpecifier;\n}\nvar lib$1 = {};\nvar lib = {};\nObject.defineProperty(lib, \"__esModule\", {\n  value: true\n});\nlib.declare = declare;\nlib.declarePreset = void 0;\nconst apiPolyfills = {\n  assertVersion: (api) => (range) => {\n    throwVersionError(range, api.version);\n  }\n};\n{\n  Object.assign(apiPolyfills, {\n    targets: () => () => {\n      return {};\n    },\n    assumption: () => () => {\n      return void 0;\n    }\n  });\n}\nfunction declare(builder) {\n  return (api, options, dirname) => {\n    var _clonedApi2;\n    let clonedApi;\n    for (const name2 of Object.keys(apiPolyfills)) {\n      var _clonedApi;\n      if (api[name2]) continue;\n      (_clonedApi = clonedApi) != null ? _clonedApi : clonedApi = copyApiObject(api);\n      clonedApi[name2] = apiPolyfills[name2](clonedApi);\n    }\n    return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);\n  };\n}\nconst declarePreset = declare;\nlib.declarePreset = declarePreset;\nfunction copyApiObject(api) {\n  let proto = null;\n  if (typeof api.version === \"string\" && /^7\\./.test(api.version)) {\n    proto = Object.getPrototypeOf(api);\n    if (proto && (!has(proto, \"version\") || !has(proto, \"transform\") || !has(proto, \"template\") || !has(proto, \"types\"))) {\n      proto = null;\n    }\n  }\n  return Object.assign({}, proto, api);\n}\nfunction has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction throwVersionError(range, version) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n    range = `^${range}.0.0-0`;\n  }\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n  const limit = Error.stackTraceLimit;\n  if (typeof limit === \"number\" && limit < 25) {\n    Error.stackTraceLimit = 25;\n  }\n  let err;\n  if (version.slice(0, 2) === \"7.\") {\n    err = new Error(`Requires Babel \"^7.0.0-beta.41\", but was loaded with \"${version}\". You'll need to update your @babel/core version.`);\n  } else {\n    err = new Error(`Requires Babel \"${range}\", but was loaded with \"${version}\". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention \"@babel/core\" or \"babel-core\" to see what is calling Babel.`);\n  }\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version,\n    range\n  });\n}\nObject.defineProperty(lib$1, \"__esModule\", {\n  value: true\n});\nvar default_1 = lib$1.default = void 0;\nvar _helperPluginUtils = lib;\ndefault_1 = lib$1.default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  let {\n    version\n  } = options;\n  {\n    const {\n      legacy\n    } = options;\n    if (legacy !== void 0) {\n      if (typeof legacy !== \"boolean\") {\n        throw new Error(\".legacy must be a boolean.\");\n      }\n      if (version !== void 0) {\n        throw new Error(\"You can either use the .legacy or the .version option, not both.\");\n      }\n    }\n    if (version === void 0) {\n      version = legacy ? \"legacy\" : \"2018-09\";\n    } else if (version !== \"2023-05\" && version !== \"2023-01\" && version !== \"2022-03\" && version !== \"2021-12\" && version !== \"2018-09\" && version !== \"legacy\") {\n      throw new Error(\"Unsupported decorators version: \" + version);\n    }\n    var {\n      decoratorsBeforeExport\n    } = options;\n    if (decoratorsBeforeExport === void 0) {\n      if (version === \"2021-12\" || version === \"2022-03\") {\n        decoratorsBeforeExport = false;\n      } else if (version === \"2018-09\") {\n        throw new Error(\"The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.\");\n      }\n    } else {\n      if (version === \"legacy\" || version === \"2022-03\" || version === \"2023-01\") {\n        throw new Error(`'decoratorsBeforeExport' can't be used with ${version} decorators.`);\n      }\n      if (typeof decoratorsBeforeExport !== \"boolean\") {\n        throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n      }\n    }\n  }\n  return {\n    name: \"syntax-decorators\",\n    manipulateOptions({\n      generatorOpts\n    }, parserOpts) {\n      if (version === \"legacy\") {\n        parserOpts.plugins.push(\"decorators-legacy\");\n      } else {\n        if (version === \"2023-01\" || version === \"2023-05\") {\n          parserOpts.plugins.push([\"decorators\", {\n            allowCallParenthesized: false\n          }], \"decoratorAutoAccessors\");\n        } else if (version === \"2022-03\") {\n          parserOpts.plugins.push([\"decorators\", {\n            decoratorsBeforeExport: false,\n            allowCallParenthesized: false\n          }], \"decoratorAutoAccessors\");\n        } else if (version === \"2021-12\") {\n          parserOpts.plugins.push([\"decorators\", {\n            decoratorsBeforeExport\n          }], \"decoratorAutoAccessors\");\n          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n        } else if (version === \"2018-09\") {\n          parserOpts.plugins.push([\"decorators\", {\n            decoratorsBeforeExport\n          }]);\n          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n        }\n      }\n    }\n  };\n});\nfunction makeVisitor(babel) {\n  const t = babel.types;\n  return {\n    Program(path, state) {\n      state.currentClassBodies = [];\n      state.currentObjectExpressions = [];\n      state.optsWithDefaults = {\n        runtime: \"globals\",\n        runEarly: false,\n        ...state.opts\n      };\n      state.util = new ImportUtil_1(babel, path);\n      state.runtime = (i, fnName) => {\n        const { runtime } = state.optsWithDefaults;\n        if (runtime === \"globals\") {\n          return t.memberExpression(\n            t.identifier(globalId),\n            t.identifier(fnName)\n          );\n        } else {\n          return i.import(runtime.import, fnName);\n        }\n      };\n    },\n    ClassBody: {\n      enter(path, state) {\n        state.currentClassBodies.unshift(path.node);\n      },\n      exit(path, state) {\n        if (state.currentClassBodies[0] === path.node) {\n          state.currentClassBodies.shift();\n        }\n      }\n    },\n    ClassExpression(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        state.util.replaceWith(path, (i) => {\n          let call = t.callExpression(state.runtime(i, \"c\"), [\n            path.node,\n            t.arrayExpression(\n              decorators.slice().reverse().map((d) => d.node.expression)\n            )\n          ]);\n          for (let decorator of decorators) {\n            decorator.remove();\n          }\n          return call;\n        });\n      }\n    },\n    ClassDeclaration(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        const buildCall = (i) => {\n          return t.callExpression(state.runtime(i, \"c\"), [\n            t.classExpression(\n              path.node.id,\n              path.node.superClass,\n              path.node.body,\n              []\n              // decorators removed here\n            ),\n            t.arrayExpression(\n              decorators.slice().reverse().map((d) => d.node.expression)\n            )\n          ]);\n        };\n        if (path.parentPath.isExportDefaultDeclaration()) {\n          let id = path.node.id;\n          if (id) {\n            state.util.insertBefore(\n              path.parentPath,\n              (i) => t.variableDeclaration(\"const\", [\n                t.variableDeclarator(id, buildCall(i))\n              ])\n            );\n            path.parentPath.replaceWith(t.exportDefaultDeclaration(id));\n          } else {\n            state.util.replaceWith(\n              path.parentPath,\n              (i) => t.exportDefaultDeclaration(buildCall(i))\n            );\n          }\n        } else if (path.parentPath.isExportNamedDeclaration()) {\n          let id = path.node.id;\n          if (!id) {\n            throw new Error(\n              `bug: expected a class name is required in this context`\n            );\n          }\n          state.util.insertBefore(\n            path.parentPath,\n            (i) => t.variableDeclaration(\"const\", [\n              t.variableDeclarator(id, buildCall(i))\n            ])\n          );\n          path.parentPath.replaceWith(\n            t.exportNamedDeclaration(null, [t.exportSpecifier(id, id)])\n          );\n        } else {\n          let id = path.node.id;\n          if (!id) {\n            throw new Error(\n              `bug: expected a class name is required in this context`\n            );\n          }\n          state.util.replaceWith(\n            path,\n            (i) => t.variableDeclaration(\"const\", [\n              t.variableDeclarator(id, buildCall(i))\n            ])\n          );\n        }\n      }\n    },\n    ClassProperty(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        let prototype;\n        if (path.node.static) {\n          prototype = t.thisExpression();\n        } else {\n          prototype = t.memberExpression(\n            t.thisExpression(),\n            t.identifier(\"prototype\")\n          );\n        }\n        let args = [\n          prototype,\n          valueForFieldKey(t, path.node.key),\n          t.arrayExpression(\n            decorators.slice().reverse().map((d) => d.node.expression)\n          )\n        ];\n        if (path.node.value) {\n          args.push(\n            t.functionExpression(\n              null,\n              [],\n              t.blockStatement([t.returnStatement(path.node.value)])\n            )\n          );\n        }\n        state.util.insertBefore(\n          path,\n          (i) => t.staticBlock([\n            t.expressionStatement(\n              t.callExpression(state.runtime(i, \"g\"), args)\n            )\n          ])\n        );\n        state.util.insertBefore(\n          path,\n          (i) => t.classPrivateProperty(\n            t.privateName(\n              t.identifier(\n                unusedPrivateNameLike(state, propName(path.node.key))\n              )\n            ),\n            t.sequenceExpression([\n              t.callExpression(state.runtime(i, \"i\"), [\n                t.thisExpression(),\n                valueForFieldKey(t, path.node.key)\n              ]),\n              t.identifier(\"void 0\")\n            ])\n          )\n        );\n        path.remove();\n      }\n    },\n    ClassMethod(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        let prototype;\n        if (path.node.static) {\n          prototype = t.thisExpression();\n        } else {\n          prototype = t.memberExpression(\n            t.thisExpression(),\n            t.identifier(\"prototype\")\n          );\n        }\n        state.util.insertAfter(\n          path,\n          (i) => t.staticBlock([\n            t.expressionStatement(\n              t.callExpression(state.runtime(i, \"n\"), [\n                prototype,\n                valueForFieldKey(t, path.node.key),\n                t.arrayExpression(\n                  decorators.slice().reverse().map((d) => d.node.expression)\n                )\n              ])\n            )\n          ])\n        );\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n    ObjectExpression: {\n      enter(path, state) {\n        state.currentObjectExpressions.unshift({\n          node: path.node,\n          decorated: []\n        });\n      },\n      exit(path, state) {\n        var _a;\n        if (((_a = state.currentObjectExpressions[0]) == null ? void 0 : _a.node) !== path.node) {\n          return;\n        }\n        let { decorated } = state.currentObjectExpressions.shift();\n        if (decorated.length > 0) {\n          state.util.replaceWith(\n            path,\n            (i) => t.callExpression(state.runtime(i, \"p\"), [\n              path.node,\n              t.arrayExpression(\n                decorated.map(\n                  ([type, prop, decorators]) => t.arrayExpression([\n                    t.stringLiteral(type),\n                    prop,\n                    t.arrayExpression(decorators)\n                  ])\n                )\n              )\n            ])\n          );\n        }\n      }\n    },\n    ObjectProperty(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        if (state.currentObjectExpressions.length === 0) {\n          throw new Error(\n            `bug in decorator-transforms: didn't expect to see ObjectProperty outside ObjectExpression`\n          );\n        }\n        let prop = path.node.key;\n        if (prop.type === \"PrivateName\") {\n          throw new Error(`cannot decorate private field`);\n        }\n        state.currentObjectExpressions[0].decorated.push([\n          \"field\",\n          valueForFieldKey(t, prop),\n          decorators.slice().reverse().map((d) => d.node.expression)\n        ]);\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n    ObjectMethod(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        if (state.currentObjectExpressions.length === 0) {\n          throw new Error(\n            `bug in decorator-transforms: didn't expect to see ObjectMethod outside ObjectExpression`\n          );\n        }\n        let prop = path.node.key;\n        state.currentObjectExpressions[0].decorated.push([\n          \"method\",\n          valueForFieldKey(t, prop),\n          decorators.slice().reverse().map((d) => d.node.expression)\n        ]);\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    }\n  };\n}\nfunction legacyDecoratorCompat(babel) {\n  let visitor = makeVisitor(babel);\n  return {\n    inherits: (api, _options, dirname) => default_1(api, { legacy: true }, dirname),\n    pre(file) {\n      if (this.opts.runEarly) {\n        babel.traverse(file.ast, makeVisitor(babel), file.scope, this);\n        visitor = void 0;\n      }\n    },\n    get visitor() {\n      return visitor ?? {};\n    }\n  };\n}\nfunction unusedPrivateNameLike(state, name2) {\n  let classBody = state.currentClassBodies[0];\n  if (!classBody) {\n    throw new Error(\n      `bug: no current class body around our class field decorator`\n    );\n  }\n  let usedNames = /* @__PURE__ */ new Set();\n  for (let element of classBody.body) {\n    if ((element.type === \"ClassPrivateProperty\" || element.type === \"ClassPrivateMethod\" || element.type === \"ClassAccessorProperty\") && element.key.type === \"PrivateName\") {\n      usedNames.add(element.key.id.name);\n    }\n  }\n  let candidate = name2;\n  while (usedNames.has(candidate)) {\n    candidate = candidate + \"_\";\n  }\n  return candidate;\n}\nfunction propName(expr) {\n  if (expr.type === \"Identifier\") {\n    return expr.name;\n  }\n  if (expr.type === \"BigIntLiteral\" || expr.type === \"NumericLiteral\") {\n    return `_${expr.value}`;\n  }\n  if (expr.type === \"StringLiteral\") {\n    return \"_\" + expr.value.replace(/[^a-zA-Z]/g, \"\");\n  }\n  return \"_\";\n}\nfunction valueForFieldKey(t, expr) {\n  if (expr.type === \"Identifier\") {\n    return t.stringLiteral(expr.name);\n  }\n  return expr;\n}\nexport {\n  legacyDecoratorCompat as default\n};\n//# sourceMappingURL=index.js.map\n"],"names":["globalId","Object","defineProperty","src","value","ImportUtil_1","ImportUtil","constructor","babel","program","t","types","removeImport","moduleSpecifier","exportedName","topLevelPath","get","matchModule","importSpecifierPath","find","specifierPath","matchSpecifier","node","specifiers","length","remove","removeAllImports","import","target","nameHint","unreferencedImport","desiredName","defaultNameHint","preferredName","_a","isNamespaceImport","isDefaultImport","isNamedImport","declaration","findImportFrom","hasNamespaceSpecifier","s","type","hasNamedSpecifiers","cannotUseExistingDeclaration","specifier","spec","scope","getBinding","local","name","kind","identifier","addSpecifier","declaration2","insertAfterExistingImports","importDeclaration","stringLiteral","importForSideEffect","replaceWith","fn","mutate","i","insertAfter","insertBefore","defaultNameHint2","symbols","Map","importer","set","updateReference","path","isIdentifier","hit","newIdentifier","binding","Error","reference","result","traverse","ReferencedIdentifier","unusedNameLike","buildSpecifier","added","unshift","push","registerBinding","localName","importDefaultSpecifier","importNamespaceSpecifier","importSpecifier","isImportDeclaration","source","importKind","statement","lastIndex","index","body","entries","splice","name2","candidate","counter","hasBinding","cleaned","replace","_m","letter","toUpperCase","generateUidIdentifierBasedOnNode","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported"],"mappings":"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","x_google_ignoreList":[0,1]}
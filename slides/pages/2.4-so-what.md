---
title: So what?
---

# What we can do with all this knowledge?

<span style="font-size: 0.9rem; position: absolute; top: 10rem; left: 0rem;transform: rotate(-90deg);">the knowledge</span>
<ul style="font-size: 2rem;">

<li v-click>debugging</li>
<li v-click>patching</li>
<li v-click>rendering</li>
<li v-click>booting</li>
</ul>

<!--

What have we learned so far?

[click] - debugging

[click] - patching

[click] - how rendering works

[click] - and now how booting works


And when we put it all together

-->

---

<div class="centered">
	<h1 style="font-size: 4rem; font-style: italic; font-family: 'Comic Sans MS'">✨ you can do anything ❤️</h1>
	<div v-click style="position: absolute; transform:rotate(-4deg); right: 1rem; bottom: 1rem; width: 200px; font-size: 0.8rem;">with enough time, determination, patience, collaboration, stubborness, sleep, acceptance, food, and kpop demon hunters
	</div>
</div>	

<!-- 

You can do anything.

[click] you unlock and unblock your imagination. 

You are limitless.
-->


---
title: REPL
class: layout-full
clicks: 2
---

# with the _power of patching_ (pop)

<div class="iframe-chrome">
	<div class="iframe-chrome-tab">
	  REPL | limber.glimdown.com
	</div>
	<iframe src="https://limber.glimdown.com/edit?c=JYWwDg9gTgLgBAYQuCA7Apq%2BAzKy4DkAAgOYA2oI6UA9AMbKQZYEDcAUKJLHAN5wwoAQzoBrdABM4AXzi58xcpWo1BI0cFQk27dnTJCAzobgAJdGTIQA6tDJT0ADxiYJJpCmbxe7OHCJqYpJwDACuWHAAvHAADBx%2BmnRQ6FQR0QAUAJRRAHwCABbAhgB0YREA1NEAjBy%2BcAA8LuAGLjl1fgCaEKFw%2BUIAbughFEFSMPlDAEahMDBocO18vONFpd1Y0rIwoOglun5%2B9dOz83Bo%2BsBikbzLhSWJyakwm20HBwgjoov1NMdzqK8GqoUmAWug2tJdE5uPAJOhsEJQmR4OZLDY7BIOEA&format=gjs&editor=60v&forceEditor=true"></iframe>
</div>		


<Show on="1">
 <div style="
	width: 40%;
	position: absolute;
	top: 5rem;
	bottom: 2rem;
	right: 2rem;
	border: 3px solid red;
"></div>
</Show>

<Show on="2">
<div  style="
	position: absolute;
	bottom: 5rem;
	right: 5rem;
	background: rgba(255,225,225,1);
	border-radius: 0.25rem;
	color: black;
	padding: 1rem;
		font-weight: bold;
	border: 1px solid;
border-color: rgb(185 28 28);
	width: 50%;
">
Attempted to rerender, but the Ember application has had an unrecoverable error occur during render. 
You should reload the application after fixing the cause of the error.
</div>
</Show>

<!--

This REPL here renders an ember app inside an ember app.

This is not an engine, because I needed the output side of the REPL to 
not share any app-wide state with the host application.

It doesn't use `renderComponent`, because I need separate renderers for the right-hand side 

[click] This right-hand side often crashes, due to rendering incomplete code every couple hundred
milliseconds.

[click] If I were to use `renderComponent`, I'd receive this error about an unrecoverable error.

But when using the "whole application" approach -- ember currently forbids rendering a whole app inside a whole app -- so I patched that out.


`renderComponent` causing this error for good reason -- it's because of an optimization -- it shares the same
renderer of the host ember application if one exists on the passed in owner.

The fix for this behavior with `renderComponent` will likely be a new syntax:

-->

---

# try/catch in templates

<div class="medium-code">

```gjs
<template>
	{{#try}}

		<CauseError />

	{{catch as |error|}}

		Oh no, you hit 
		<br> {{error}}

	{{/try}}
</template>
```

</div>	

<!-- 

template-based try/catch.

it is a bit different from javascript try/catch.

it doesn't exist, but has been explored once or twice by Yehuda. 

This is something that may need RFC to discuss exact behaviors, like what information to expose in
the error block param.

In any case, _I_ need it for making the REPL better, 

and hopefully -- now -- I'll have some time to help ship some version of this.

With the current implementation of the renderer, it's a little too complicated for a patch.

So....

-->

---

```diff
diff --git a/dist/packages/@ember/-internals/views/lib/system/event_dispatcher.js b/dist/packages/@ember/-internals/views/lib/system/event_dispatcher.js
index e1525ab88772a03d6aa3b190ea21a9785271edd4..9a2a11a83d90e69600777ae4a401efecf99be4fc 100644
--- a/dist/packages/@ember/-internals/views/lib/system/event_dispatcher.js
+++ b/dist/packages/@ember/-internals/views/lib/system/event_dispatcher.js
@@ -147,26 +147,6 @@ class EventDispatcher extends EmberObject {
     let rootElement = typeof specifiedRootElement !== 'string' ? specifiedRootElement : document.querySelector(specifiedRootElement);
     (isDevelopingApp() && !(rootElement) && assert(`Could not find rootElement (${specifiedRootElement})`, rootElement));
     (isDevelopingApp() && !(!rootElement.classList.contains(ROOT_ELEMENT_CLASS)) && assert(`You cannot use the same root element (${specifiedRootElement}) multiple times in an Ember.Application`, !rootElement.classList.contains(ROOT_ELEMENT_CLASS)));
-    (isDevelopingApp() && !((() => {
-      let target = rootElement.parentNode;
-      while (target instanceof Element) {
-        if (target.classList.contains(ROOT_ELEMENT_CLASS)) {
-          return false;
-        }
-        target = target.parentNode;
-      }
-      return true;
-    })()) && assert('You cannot make a new Ember.Application using a root element that is a descendent of an existing Ember.Application', (() => {
-      let target = rootElement.parentNode;
-      while (target instanceof Element) {
-        if (target.classList.contains(ROOT_ELEMENT_CLASS)) {
-          return false;
-        }
-        target = target.parentNode;
-      }
-      return true;
-    })()));
-    (isDevelopingApp() && !(!rootElement.querySelector(ROOT_ELEMENT_SELECTOR)) && assert('You cannot make a new Ember.Application using a root element that is an ancestor of an existing Ember.Application', !rootElement.querySelector(ROOT_ELEMENT_SELECTOR)));
     rootElement.classList.add(ROOT_ELEMENT_CLASS);
     (isDevelopingApp() && !(rootElement.classList.contains(ROOT_ELEMENT_CLASS)) && assert(`Unable to add '${ROOT_ELEMENT_CLASS}' class to root element (${get(this, 'rootElement') || rootElement.tagName}). Make sure you set rootElement to the body or an element in the body.`, rootElement.classList.contains(ROOT_ELEMENT_CLASS))); // save off the final sanitized root element (for usage in setupHandler)
     this._sanitizedRootElement = rootElement;
diff --git a/dist/packages/@ember/template-compiler/lib/template.js b/dist/packages/@ember/template-compiler/lib/template.js
index a70b8d37d008ee91df0a25677e435573f14f195b..e4f3142947b6959ed8510dae70a31211eb46e89b 100644
--- a/dist/packages/@ember/template-compiler/lib/template.js
+++ b/dist/packages/@ember/template-compiler/lib/template.js
@@ -2110,11 +2110,9 @@ function template(templateString, providedOptions) {
   const evaluate = buildEvaluator(options);
   const normalizedOptions = compileOptions(options);
   const component = normalizedOptions.component ?? templateOnly();
-  queueMicrotask(() => {
     const source = precompile(templateString, normalizedOptions);
     const template = templateFactory(evaluate(`(${source})`));
     setComponentTemplate(template, component);
-  });
   return component;
 }
 const evaluator = source => {
```

<img v-click style="position: absolute; bottom: 2rem; right: 2rem; max-width: 200px;" src="/images/wagenet.jpeg" />

<!-- 

... here is the patch I'm using in the REPL.

And this is needed because I'm using the "boot a whole app just to render a component approach"

But, I've removed the code around *asserting* against nested applications in the event dispatcher.

which reminds me, encountering this sent me on a mission to eliminate the event dispatcher
entirely.. But it's been a huuuge yak shave.

[click] `@wagenet` has been helping a ton with that as well -- it ultimately ends up requiring deprecating
and then deleteing a ton of pre-octane code.

-->


---
title: Effects lol
---

# with the _power of patching_ (pop)


<div class="two-columns">

```gjs
import { tracked } from '@glimmer/tracking';
import { subtle } from '@ember/renderer';

class Demo {
  @tracked count = 0;
  increment = () => this.count++;
}

const demo = new Demo();

subtle.sync(() => {
  console.log(demo.count);
});

<template>
  {{demo.count}}
  <button onclick={{demo.increment}}>++</button>
</template>
```


<div class="iframe-chrome">
	<div class="iframe-chrome-tab">
	  Effects, lol 
	</div>
	<iframe src="/demos/effects/index.html"></iframe>
</div>		

</div>

<div v-click="1" hide 
	style="
	position: absolute;
	border: 3px solid red;
	top: 17rem;
    left: 3.5rem;
    width: 13rem;
	height: 5.5rem;
		pointer-events: none;
	"></div>

<div v-click="2" hide
	style="
	position: absolute;
	border: 3px solid red;
	top: 7rem;
    right: 25rem;
    width: 8rem;
	height: 3.5rem;
		pointer-events: none;
	"></div>

<!-- 

Combining the power of patching with the knowledge of rendering, we can do some fun things 

[click] In this example here, we call a subtle API I've named "sync" for synchronize. 

Normally when you want to make a side-effect you have to call a function from the template. 

[click] I'll prove this works here by clicking this button and showing you the source.
this isn't lies. 

[don't read]

remember to shift click

demo by clicking on the live screen (remember to go through the Debugger to oppen the app.js
(application.gts)

		- show original file (source-maps enabled)


Without the power of patching (today at least), you can't do this.

-->

---

<div class="effects-patch-code">

```diff {*}{lines:true}
diff --git a/dist/packages/@ember/renderer/index.js b/dist/packages/@ember/renderer/index.js
index 1e7f5c9cd96f38f3ffd0dff6870b7e097a1a0758..ce998b530d888baf8e1409294c3c887844301f95 100644
--- a/dist/packages/@ember/renderer/index.js
+++ b/dist/packages/@ember/renderer/index.js
@@ -8,3 +8,4 @@ import '../../@glimmer/reference/index.js';
 import '../../@glimmer/validator/index.js';
 import '@embroider/macros';
 import '../../@glimmer/manager/index.js';
+export { subtle } from './sync.js';
diff --git a/dist/packages/@ember/renderer/sync.js b/dist/packages/@ember/renderer/sync.js
new file mode 100644
index 0000000000000000000000000000000000000000..a3c477bac23c9ebea3ebdf54669e5938a8e8eaf7
--- /dev/null
+++ b/dist/packages/@ember/renderer/sync.js
@@ -0,0 +1,21 @@
+import { createCache, getValue } from '../../@glimmer/validator/index.js';
+
+let caches = [];
+
+
+export const subtle = {
+  flushSync() {
+    caches.forEach(cache => {
+      getValue(cache);
+    });
+  },
+  sync(fn) {
+    let cache = createCache(fn);
+
+    caches.push(cache);
+
+    return () => {
+      caches = caches.filter(c => c!==cache)
+    }
+  }
+}
diff --git a/dist/packages/shared-chunks/index-D-GTx_Yt.js b/dist/packages/shared-chunks/index-D-GTx_Yt.js
index 274d4d6dd3978811308ecfbcf6c27ccc51e10a36..702c4ca8f70954b13b2b5ee9bbdc22439a93433d 100644
--- a/dist/packages/shared-chunks/index-D-GTx_Yt.js
+++ b/dist/packages/shared-chunks/index-D-GTx_Yt.js
@@ -1,3 +1,4 @@
+import { subtle } from '../@ember/renderer/index.js';
 import { templateFactory, EvaluationContextImpl } from '../@glimmer/opcode-compiler/index.js';
 import { g as getFactoryFor, p as privatize } from './registry-BJpQx6hv.js';
 import { warn, debugFreeze, deprecate } from '../@ember/debug/index.js';
@@ -5470,6 +5471,7 @@ class Renderer {
             continue;
           }
           root.render();
+          subtle.flushSync();
         }
         this._lastRevision = valueForTag(CURRENT_TAG);
       });
```

</div>	

<div v-click class="box" style="top: 19rem; width: 250px; height: 5rem; left: 6rem;"></div>
<img v-after v-click.hide="2" src="/images/kpdh/saja-grimmace.png" style="position: absolute; right: 0;
width:400px;"/>
<img v-click style="position:absolute; top: 5rem; left: 1rem;border: 4px solid red;" src="/images/flush-async-observers.png" />

<div v-click style="position:absolute; top: 6rem; left: 3rem; z-index: 10;">
	<h2 style="color: red; font-weight: bold; transform: rotate(-10deg); font-size: 18rem;
		font-family: arial;
	text-shadow: 0 0 20px black;
  -webkit-text-stroke-width: 6px;
  -webkit-text-stroke-color: black;
	">sus</h2>
</div>

<!-- 

Here is the patch used for creating effects

it's about 20 lines.

But this isn't a good implementation.

[click] this is the returned cleanup function, and in the demo I showed earlier -- it's never
called.

This is one of the tricky things about effects is that you can't just use
them willy-nilly -- you need some way to dispose of them -- and a time to dispose of them. 

So, ergonomic effects necessarily need to be tied in to the rendering and ownership system.

[click] This is actually very similar to the flushAsyncObservers code we saw earlier. and observers
have cleanup configured due to how they can only be used within a class that already has destruction
and ownership linkage. 

[click] However, for all the reasons observers are a [sus]uation in app code, so too
are effects.

-->


---
title: Astro
---

# astro.build

With the previously mentioned knowledge of how an app boots,
we can write an astro integration in only a few lines.

<div style="
		display:grid; 
		grid-template-columns: min-content 1fr; 
		align-items: start;
		gap:1rem">
		
```js
import { defineConfig } from "astro/config";
import { ember } from "ember-astro";

export default defineConfig({
	integrations: [ember()],
});
```

```astro
---
import HelloWorld from '../components/demo.gjs';
---

<html>
  <body>
    <h1>Use Ember components directly in Astro!</h1>
    <HelloWorld client:only="ember" />
    <HelloWorld /> <!-- SSG coming soon -->
  </body>
</html>
```

</div>

<QRCode 
	style="margin-top:-5rem; transform: scale(0.8); transform-origin: 0 0"
  class="qr-code" 
  type="svg" 
	data="https://github.com/ember-tooling/ember-astro" />


<!-- 

Last year, at emberfest, I said that that are no technical limitations preventing ember from used
in other projects.

Now, this is more true today than last year, but even back then, all anyone needed to know to
integrate ember into another projcet is how to boot it.

There isn't any need to know how rendering works to get the basic integration done.

I made the astro integration linked at this QR Code in like, no time at all. Most of what I was
learning during this process was what astro wanted from me, and how to use astro.

But! now that this exists, I'll probably start trying to use astro more in my projects.
There is a certain beauty to making sites with static HTML as the default, and sprinkled in
reactivity here in there.

Very different from web applications, but I'm going to try exploring what I can do with docs with
this.
-->

---
title: Astro how
---

# astro.build (inside)


```js

export default function emberAstroClientRenderer(element) {
	return async (component, props, slots) => {
		let result = await renderComponent(component, { into: element });

		element.addEventListener("astro:unmount", () => result.destroy(), { once: true });
	};
}
```

This is the whole (minimal) integration

<!-- 

This is the whole minimal integration.

This is essentially 2 lines and the rest is well-documented astro boilerplate.

-->

---
title: Astro (with props)
---

# astro.build (inside - props passing)


```js
import { template } from "@ember/template-compiler";

function withProps(props, slots, component) {
	return template(`<component @props={{props}} @slots={{slots}} />`, {
		scope: () => ({
			props,
			slots,
			component,
		}),
	});
}


export default function emberAstroClientRenderer(element) {
	return async (component, props, slots) => {
		let result = await renderComponent(withProps(props, slots, component), { into: element });

		element.addEventListener("astro:unmount", () => result.destroy(), { once: true });
	};
}
```
<QRLink href="https://github.com/emberjs/rfcs/pull/931" label="RFC #931" />

<!-- 

And then if we want to integrate with astro's props, we need 
to come up with a way to dynamically pass them.

We need a stable reference, as the `template()` here at the top from the template-compiler must have
statically referenced arguments so as to not re-render unneededly.

-->

---


<div style="display: flex; justify-content: center; width: 100%;">
<img style="width: 300px;" src="/images/ghostty-logo.svg" />
</div>


<!-- 

Uhm, ya -- let's see if I can do a live demo here, 

because I don't think there is any other way to 

truethfully demonstrate this.


[just boot up the CLI app and click the button a couple times]

-->

---
title: CLI
---

<div style="display: flex; justify-content: center; align-items: center; width: 100%; height:60%;">

<h1 style="font-size:6rem">Ember in the CLI</h1>

</div>

<!--

The technique done here to render in the CLI does require some rendering knowledge,

But the tl;dr: is that if you want to persue this, you might want to do what I sorta did and re-implement
browser APIs in node, and adjust how they render to adopt for the terminal.

-->

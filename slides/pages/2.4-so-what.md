---
title: So what?
---

# What we can do with all this knowledege?

<span style="font-size: 0.9rem; position: absolute; top: 10rem; left: 0rem;transform: rotate(-90deg);">the knowledge</span>
<ul style="font-size: 2rem;">

<li v-click>debugging</li>
<li v-click>patching</li>
<li v-click>rendering</li>
<li v-click>booting</li>
</ul>

<!--

What have we learned so far?

[click] - debugging

[click] - patching

[click] - how rendering works

[click] - and now how booting works


And when we put it all together

-->

---

<div class="centered">
	<h1 style="font-size: 4rem; font-style: italic; font-family: 'Comic Sans MS'">✨ you can do anything ❤️</h1>
	<div v-click style="position: absolute; transform:rotate(-4deg); right: 1rem; bottom: 1rem; width: 200px; font-size: 0.8rem;">with enough time, determination, patience, collaboration, stubborness, sleep, acceptance, food, and kpop demon hunters
	</div>
</div>	

<!-- 

You can do anyhting.

[click] you unlock and unblock your imagination. 

You are limitless.
-->


---
title: REPL
class: layout-full
---

# with the _power of patching_ (pop)

<div class="iframe-chrome">
	<div class="iframe-chrome-tab">
	  REPL | limber.glimdown.com
	</div>
	<iframe src="https://limber.glimdown.com/edit?c=JYWwDg9gTgLgBAYQuCA7Apq%2BAzKy4DkAAgOYA2oI6UA9AMbKQZYEDcAUKJLHAN5wwoAQzoBrdABM4AXzi58xcpWo1BI0cFQk27dnTJCAzobgAJdGTIQA6tDJT0ADxiYJJpCmbxe7OHCJqYpJwDACuWHAAvHAADBx%2BmnRQ6FQR0QAUAJRRAHwCABbAhgB0YREA1NEAjBy%2BcAA8LuAGLjl1fgCaEKFw%2BUIAbughFEFSMPlDAEahMDBocO18vONFpd1Y0rIwoOglun5%2B9dOz83Bo%2BsBikbzLhSWJyakwm20HBwgjoov1NMdzqK8GqoUmAWug2tJdE5uPAJOhsEJQmR4OZLDY7BIOEA&format=gjs&editor=60v&forceEditor=true"></iframe>
</div>		

<div v-click.show="1" v-click.hide="2" style="
	width: 40%;
	position: absolute;
	top: 5rem;
	bottom: 2rem;
	right: 2rem;
	border: 3px solid red;
"></div>

<div v-click.show="2" style="
	position: absolute;
	bottom: 5rem;
	right: 5rem;
	background: rgba(255,225,225,1);
	border-radius: 0.25rem;
	color: black;
	padding: 1rem;
		font-weight: bold;
	border: 1px solid;
border-color: rgb(185 28 28);
	width: 50%;
">
Attempted to rerender, but the Ember application has had an unrecoverable error occur during render. 
You should reload the application after fixing the cause of the error.
</div>

<!--

This REPL here renders an ember app inside an ember app.

This is not an engine, because I needed the output side of the REPL to 
not share any app-wide state with the host application.

It doesn't use `renderComponent`, because I need separate renderers 

[click] for the right-hand side. 

This right-hand side often crashes, due to rendering incomplete code every couple hundred
milliseconds.

[click] If I were to use `renderComponent`, I'd receive this error about an unrecoverable error.

But when using the "whole application" approach -- ember currently forbids rendering a whole app inside a whole app -- so I patched that out.





-->


---
title: Effects lol
---

# with the _power of patching_ (pop)


<div class="two-columns">

```gjs
import { tracked } from '@glimmer/tracking';
import { subtle } from '@ember/renderer';

class Demo {
  @tracked count = 0;
  increment = () => this.count++;
}

const demo = new Demo();

subtle.sync(() => {
  console.log(demo.count);
});

<template>
  {{demo.count}}
  <button onclick={{demo.increment}}>++</button>
</template>
```


<div class="iframe-chrome">
	<div class="iframe-chrome-tab">
	  Effects, lol 
	</div>
	<iframe src="/demos/effects/index.html"></iframe>
</div>		

</div>

<div v-click
	style="
	position: absolute;
	border: 3px solid red;
	top: 17rem;
    left: 3.5rem;
    width: 13rem;
	height: 5.5rem;
	"></div>

<!-- 

Combining the power of patching with the knowledge of rendering, we can implement rendering.

[click] In this example here, we call a subtle API I've named "sync" for synchronize. 

Normally when you want to make a side-effect you have to call a function from the template. 

I'll prove this works here by clicking this button and showing you the source.
this isn't lies. 
- demo by clicking on the live screen (remember to go through the Debugger to oppen the app.js
(application.gts)
- show original file (source-maps enabled)


Without the power of patching (today at least), you can't do this.

-->


---
title: Astro
---

# astro.build

With the previously mentioned knowledge of how an app boots,
we can write an astro integration in only a few lines.

<div style="
		display:grid; 
		grid-template-columns: min-content 1fr; 
		align-items: start;
		gap:1rem">
		
```js
import { defineConfig } from "astro/config";
import { ember } from "ember-astro";

export default defineConfig({
	integrations: [ember()],
});
```

```astro
---
import HelloWorld from '../components/demo.gjs';
---

<html>
  <body>
    <h1>Use Ember components directly in Astro!</h1>
    <HelloWorld client:only="ember" />
    <HelloWorld /> <!-- SSG coming soon -->
  </body>
</html>
```

</div>

<QRCode 
	style="margin-top:-5rem; transform: scale(0.8); transform-origin: 0 0"
  class="qr-code" 
  type="svg" 
	data="https://github.com/ember-tooling/ember-astro" />


<!-- 

Last year, at emberfest, I said that that are no technical limitations preventing ember from used
in other projects.

Now, this is more true today than last year, but even back then, all anyone needed to know to
integrate ember into another projcet is how to boot it.

I made the astro integration linked at this QR Code in like, no time at all. Most of what I was
learning during this process was what astro wanted from me, and how to use astro.

But! now that this exists, I'll probably start trying to use astro more in my projects.
There is a certain beauty to making sites with static HTML as the default, and sprinkled in
reactivity here in there.

Very different from web applications, but I'm going to try exploring what I can do with docs with
this.
-->

---
title: Astro how
---

# astro.build (inside)


```js

export default function emberAstroClientRenderer(element) {
	return async (component, props, slots) => {
		let result = await renderComponent(component, { into: element });

		element.addEventListener("astro:unmount", () => result.destroy(), { once: true });
	};
}
```

This is the whole (minimal) integration

<!-- 

This is the whole minimal integration.

This is essentially 2 lines and the rest is well-documented astro boilerplate.

-->

---
title: Astro (with props)
---

# astro.bulid (inside - props passing)


```js
import { template } from "@ember/template-compiler";

function withProps(props, slots, component) {
	return template(`<component @props={{props}} @slots={{slots}} />`, {
		scope: () => ({
			props,
			slots,
			component,
		}),
	});
}


export default function emberAstroClientRenderer(element) {
	return async (component, props, slots) => {
		let result = await renderComponent(withProps(props, slots, component), { into: element });

		element.addEventListener("astro:unmount", () => result.destroy(), { once: true });
	};
}
```
<QRLink href="https://github.com/emberjs/rfcs/pull/931" label="RFC #931" />

<!-- 

And then if we want to integrate with astro's props, we need 
to come up with a way to dynamically pass them.

We need a stable reference, as the `template()` here at the top from the template-compiler must have
statically referenced arguments so as to not re-render unneededly.

-->

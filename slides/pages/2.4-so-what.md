---
title: REPL
class: layout-full
---

# What can we do with this power of patching? (pop)

<div class="iframe-chrome">
	<div class="iframe-chrome-tab">
	  REPL | limber.glimdown.com
	</div>
	<iframe src="https://limber.glimdown.com/edit?c=JYWwDg9gTgLgBAYQuCA7Apq%2BAzKy4DkAAgOYA2oI6UA9AMbKQZYEDcAUKJLHAN5wwoAQzoBrdABM4AXzi58xcpWo1BI0cFQk27dnTJCAzobgAJdGTIQA6tDJT0ADxiYJJpCmbxe7OHCJqYpJwDACuWHAAvHAADBx%2BmnRQ6FQR0QAUAJRRAHwCABbAhgB0YREA1NEAjBy%2BcAA8LuAGLjl1fgCaEKFw%2BUIAbughFEFSMPlDAEahMDBocO18vONFpd1Y0rIwoOglun5%2B9dOz83Bo%2BsBikbzLhSWJyakwm20HBwgjoov1NMdzqK8GqoUmAWug2tJdE5uPAJOhsEJQmR4OZLDY7BIOEA&format=gjs&editor=60v&forceEditor=true"></iframe>
</div>		

<!--

This REPL here renders an ember app inside an ember app.

This is not an engine, because I needed the output side of the REPL to 
not share any app-wide state with the host application.

-->


---
title: Effects lol
---

# What can we do with this power of patching? (pop)


<div class="two-columns">

```gjs
import { tracked } from '@glimmer/tracking';
import { subtle } from '@ember/renderer';

class Demo {
  @tracked count = 0;
  increment = () => this.count++;
}

const demo = new Demo();

subtle.sync(() => {
  console.log(demo.count);
});

<template>
  {{demo.count}}
  <button onclick={{demo.increment}}>++</button>
</template>
```


<div class="iframe-chrome">
	<div class="iframe-chrome-tab">
	  Effects, lol 
	</div>
	<iframe src="/demos/effects/index.html"></iframe>
</div>		

</div>


---
title: Astro
---

# astro.build

With the previously mentioned knowledge of how an app boots,
we can write an astro integration in only a few lines.

<div style="
		display:grid; 
		grid-template-columns: min-content 1fr; 
		align-items: start;
		gap:1rem">
		
```js
import { defineConfig } from "astro/config";
import { ember } from "ember-astro";

export default defineConfig({
	integrations: [ember()],
});
```

```astro
---
import HelloWorld from '../components/demo.gjs';
---

<html>
  <body>
    <h1>Use Ember components directly in Astro!</h1>
    <HelloWorld client:only="ember" />
  </body>
</html>
```

</div>

<QRCode 
	style="margin-top:-4rem; transform: scale(0.8); transform-origin: 0 0"
  class="qr-code" 
  type="svg" 
	data="https://github.com/ember-tooling/ember-astro" />


<!-- 

Last year, at emberfest, I said that that are no technical limitations preventing ember from used
in other projects.

Now, this is more true today than last year, but even back then, all anyone needed to know to
integrate ember into another projcet is how to boot it.

I made the astro integration linked at this QR Code in like, no time at all. Most of what I was
learning during this process was what astro wanted from me, and how to use astro.

But! now that this exists, I'll probably start trying to use astro more in my projects.
There is a certain beauty to making sites with static HTML as the default, and sprinkled in
reactivity here in there.

Very different from web applications, but I'm going to try exploring what I can do with docs with
this.
-->

---
title: Astro how
---

# astro.build (inside)


```js

export default function emberAstroClientRenderer(element) {
	return async (component, props, slots) => {
		let result = await renderComponent(component, { into: element });

		element.addEventListener("astro:unmount", () => result.destroy(), { once: true });
	};
}
```

This is the whole (minimal) integration

<!-- 

This is the whole minimal integration.

This is essentially 2 lines and the rest is well-documented astro boilerplate.

-->

---
title: Astro (with props)
---

# astro.bulid (inside - props passing)


```js
import { template } from "@ember/template-compiler";

function withProps(props, slots, component) {
	return template(`<component @props={{props}} @slots={{slots}} />`, {
		scope: () => ({
			props,
			slots,
			component,
		}),
	});
}


export default function emberAstroClientRenderer(element) {
	return async (component, props, slots) => {
		let result = await renderComponent(withProps(props, slots, component), { into: element });

		element.addEventListener("astro:unmount", () => result.destroy(), { once: true });
	};
}
```
<QRLink href="https://github.com/emberjs/rfcs/pull/931" label="RFC #931" />

<!-- 

And then if we want to integrate with astro's props, we need 
to come up with a way to dynamically pass them.

We need a stable reference, as the `template()` here at the top from the template-compiler must have
statically referenced arguments so as to not re-render unneededly.

-->

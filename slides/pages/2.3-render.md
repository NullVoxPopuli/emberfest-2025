---
layout: section
---

# ✨ Rendering ✨ 

<!-- 

We'll come back to patching momentarily, but first we'll need to talk about rendering.


-->


---

# What happens when

<REPL
	height="40dvh"
	code="import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
//--
export default class Demo extends Component {
  @tracked count = 0;
  increment = () => this.count++;
//--
  <template>
	<p>The count is: {{this.count}}</p>
    <button onclick={{this.increment}}>
      increment
    </button>
  </template>
}
"/>

<Arrow v-click x1="100" y1="400" x2="180" y2="360" color="red" />
<Arrow v-click.after x1="600" y1="140" x2="640" y2="190" color="red" />

<!-- 

What happens when this button is clicked?

We know that the `increment` function will get called here.
And that increment function increments `this.count`

But then _why_ does a change in counte cause the template to be updated?

-->


---


<div class="two-columns">

<div>

## Inside-out

<img src="/images/debugging-inside-out.png" />

</div>

<div v-click="1">

## Outside-in

<img v-click.show="2" v-click.hide="3" src="/images/into-the-unknown.png">
<img  v-click="3" style="position: absolute; top:5rem; max-height: 80%" src="/images/down-the-rabbit-hole.png">

</div>

</div>

<!-- 

Previous debugging techniques are a sort of "inside-out" debugging, 
where we start at a specific line of code, and inspect the surrounding areas or work back up the
stack to figure out where something went wrong.

[click] the other way to figure out what's going on is what I'm going to call "outside-in"
debugging. Where we start with our code, 
[click] and dive in to the unknown, 
[click] down the rabbit hole..

-->


---

<img src="/images/debug-render-initial.png" />

<!--

Here is our starting component.

With our knowledge of how class properties work, we can combine previous debugging knowledge to
set this up

-->

---

<img src="/images/debug-render-setup.png" />

<!--

We don't have to search around in the ember and glimmer codebases to understand what's going on,
though we certainly could.

But less error-prone way of discoverying what happens can be done via renaming our tracked
property, and defining a getter and setter pair that intercepts the read and writes to the tracked
property.

-->


---

<img src="/images/debug-render-initial-break.png" />

<!-- 

Now we can put a breakpoint there in the compiled output.


Oh, btw, in case anyone is wondering, -- I totally could have do this live, but I don't trust
myself to remain a functioning human when doing improv debugging.
-->


---

<Arrow v-click="1" x1="100" y1="200" x2="155" y2="315" color="red" />
<Arrow v-click="2" x1="600" y1="200" x2="580" y2="70" color="red" />
<img src="/images/debug-render-break-hit.png" />

<!-- 

If we click the button, our breakpoint will be hit

[click] and because we know that this assignment is special, 

[click] we can click step in to see where we end up


-->

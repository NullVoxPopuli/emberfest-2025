---
layout: section
---

# âœ¨ Rendering âœ¨ 

<!-- 

We'll come back to patching momentarily, but first we'll need to talk about rendering.


-->


---

# What happens when

<REPL
	height="40dvh"
	code="import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
//--
export default class Demo extends Component {
  @tracked count = 0;
  increment = () => this.count++;
//--
  <template>
	<p>The count is: {{this.count}}</p>
    <button onclick={{this.increment}}>
      increment
    </button>
  </template>
}
"/>

<Arrow v-click x1="100" y1="400" x2="180" y2="360" color="red" />
<Arrow v-click.after x1="600" y1="140" x2="640" y2="190" color="red" />

<!-- 

What happens when this button is clicked?

We know that the `increment` function will get called here.
And that increment function increments `this.count`

But then _why_ does a change in counte cause the template to be updated?

-->


---


<div class="two-columns">

<div>

## Inside-out

<img src="/images/debugging-inside-out.png" />

</div>

<div v-click="1">

## Outside-in

<img v-click.show="2" v-click.hide="3" src="/images/into-the-unknown.png">
<img  v-click="3" style="position: absolute; top:5rem; max-height: 80%" src="/images/down-the-rabbit-hole.png">

</div>

</div>

<!-- 

Previous debugging techniques are a sort of "inside-out" debugging, 
where we start at a specific line of code, and inspect the surrounding areas or work back up the
stack to figure out where something went wrong.

[click] the other way to figure out what's going on is what I'm going to call "outside-in"
debugging. Where we start with our code, 
[click] and dive in to the unknown, 
[click] down the rabbit hole..

-->


---

<img src="/images/debug-render-initial.png" />

<!--

Here is our starting component.

With our knowledge of how class properties work, we can combine previous debugging knowledge to
set this up

-->

---

<img src="/images/debug-render-setup.png" />

<!--

We don't have to search around in the ember and glimmer codebases to understand what's going on,
though we certainly could.

But less error-prone way of discoverying what happens can be done via renaming our tracked
property, and defining a getter and setter pair that intercepts the read and writes to the tracked
property.

-->


---

<img src="/images/debug-render-initial-break.png" />

<!-- 

Now we can put a breakpoint there in the compiled output.


Oh, btw, in case anyone is wondering, -- I totally could have do this live, but I don't trust
myself to remain a functioning human when doing improv debugging.
-->


---

<Arrow v-click="1" x1="100" y1="200" x2="155" y2="315" color="red" />
<Arrow v-click="2" x1="600" y1="200" x2="580" y2="70" color="red" />
<img src="/images/debug-render-break-hit.png" />

<!-- 

If we click the button, our breakpoint will be hit

[click] and because we know that this assignment is special, 

[click] we can click step in to see where we end up


-->

---

<Arrow v-click="1" v-click.hide="2" x1="50" y1="200" x2="155" y2="180" color="red" />
<img v-click.hide="2" src="/images/debug-render-break-step-1.png" />
<img v-click="2" v-click.hide="3" style="position: absolute; top: 2rem;" src="/images/debug-render-break-step-2.png" />
<img v-click="3" style="position: absolute; top: 2rem;" src="/images/debug-render-break-step-1.png" />

<!-- 

Here we see ourseles in this 

[click] descriptorForField function.

If this is your first time here, you may think, "that's not tracked"
Which, you're right.

[click] but if we scroll up a bit, you'll see tracked, and it that it calls this descriptorForField
function in a couple places. 

We can be reassured that we're still in the right place.

[click] but coming back to where our paused execution is, let's step in 


-->

---

<img src="/images/debug-render-break-step-3.png" />


<!-- 

We are now to step in to dirtyTag For.


At this point, if you happen to be paying enough attention to the surrounding code, you may have
noticed a fair number of optimizations we can make.

Not to worry, a bunch of us are trying to deprecate all of ember classic, so we can clean this up,
and gain some performance back.

-->

---

<img src="/images/debug-render-break-step-4.png" />

<!-- 

Here is dirtyTagFor, we want to get to the last line here, and the first part of this function is
just validation.

-->

---

<img src="/images/debug-render-break-step-5.png" />
<img 
	v-click style="position: absolute; top: 17.46rem; right: 3.55rem; max-width: 380px;" 
	src="/images/debug-render-break-step-6.png" />

<!-- 

there is an all caps DIRTY_TAG here, we'll stop in to that

[click] and if we hover over this function, we'll see it's actually an alias.

This is important because the sometimes the callsite name doesn't match the definition name.

-->

---

<img src="/images/debug-render-break-step-7.png" />

<Line v-click width="8" right="20" top="14" />

<!-- 

So here we have more validation, and then the interesting part is at the end here

[click] scheduleRevalidate.

This is interesting, because up until now, we haven't encountered anything that _sounds like_ a
side-effectful behavior.

-->

---

<img src="/images/debug-render-break-step-8.png" />

---

<img src="/images/debug-render-break-step-9.png" />

---

<img src="/images/debug-render-break-step-10.png" />

<!-- 

Here it sorta looks like we're at the end of the line.
So there must be some other mechanism by which re-rendering happens.

This is actually a key difference between ember and other frameworks that decide to render via
side-effects.

Other frameworks will try to push out updates eagerly via effects (or watchers, if you're familiar
with TC39's Signals).

We don't want to just do that -- we don't want to write to the DOM via effects because we frequently run in to situations where we have
multiple updates we need to write out to the DOM, and it's best to batch all those together. 

Any real renderer will have some sort of batching or scheduling machanism. 


This is not the end though. 

-->

---


<img src="/images/debug-render-break-step-11.png" />

<!-- 

We can see here that we're about to schedule some work to be done in the actions queue

-->

---


<img src="/images/debug-render-break-step-12.png" />

<!-- 

We're going to immediately flush the actions queue

-->

---


<img src="/images/debug-render-break-step-13.png" />

<!-- 

This is an unexpected surprise, but this bit of indirection is how we discover how async observers
are implemented.

We didn't meet the conditions to enter that if block, but 
For now we'll continue stepping in

-->

---

<img src="/images/debug-render-break-step-14.png" />
<Arrow v-click x1="600" y1="400" x2="430" y2="240" color="red" />

<!-- 

continuing to here, we see that flush is a function.
Now here in the debug tooling, there is a little caret saying we're at the beginning of this
inline anonymous arrow function. So instead of stepping in with the debug tools, I'll follow the

[click] function reference here to place a manual breakpoint

-->

---

<img src="/images/debug-render-break-step-15.png" />

<!-- 

After clicking continue, we end up here

-->

---

<img src="/images/debug-render-break-step-16.png" />

<!-- 
Usually when I do this, I'll remove the breakpoint right away.


Anywho, stepping in to the `end` invocation at the end there

-->
---

<img src="/images/debug-render-break-step-17.png" />

<!-- 

Here we find ourselves about ready to flush again.

I'll skip over going in to `flush` -- the queue is actually empty right now, so there isn't any
work to do at this time during the actions phase.


-->

---

<img src="/images/debug-render-break-step-18.png" />
<img 
	style="position: absolute; top: 12.83rem; left: 13.6rem; max-width: 120px;"
	src="/images/debug-render-break-step-18.1.png" />

<!-- 

This is the next interesting bit.
This is where queue advancement happens.

Here we can see that we're advancing tho the `routerTransitions` queue.

For the sake of time, we're going skip stepping through all this until we get to the `render` phase -- which is actually right after `routerTransitions`

-->

---

<div class="image-stack no-border auto">

<img v-after src="/images/debug-render-break-step-19.png" />
<img v-click src="/images/debug-render-break-step-19.1.png" />
<img v-click src="/images/debug-render-break-step-19.2.png" />
<img v-click src="/images/debug-render-break-step-19.3.png" />
<img v-click src="/images/debug-render-break-step-19.4.png" />
<img v-click src="/images/debug-render-break-step-19.5.png" />
<img v-click src="/images/debug-render-break-step-19.6.png" />
<img v-click src="/images/debug-render-break-step-19.7.png" />


</div>

<!-- 
So here we're about to start the render queue!

[click] in to scheduleAutorun

[click] now to step in to flush 

[click] now we do see that asyncObservers are running, but we don't care right now 

[click] we have to do this trick again

[click] stepping in to end, because that's what completes the work 

[click] well, nearly, we need to step in to this flush

[click] here in flush, we see that the queue itself also has a flush method

-->

---

<img style="position: absolute; top: 0;" src="/images/debug-render-break-step-19.8.png" />

<!-- 

and finally here, in the queue's own flush we have something interesting!  We can see a
few things in the list of queue items that we probably want to poke at before continuing
execution in the debugger

In particular, there is this function here that is passed a renderer. Let's look at that.
-->

---

<div class="image-stack no-border auto">

<img v-after src="/images/debug-render-break-step-20.png" />
<img v-click src="/images/debug-render-break-step-20.1.png" />
<img v-click src="/images/debug-render-break-step-20.2.png" />
<img v-click src="/images/debug-render-break-step-20.3.png" />

</div>	

<!-- 

This code is in ember. 

This is good, 

[click] let's set a breakpoint here and so we can skip parts of the queue that likely don't cause
rendering.

[click] hitting continue gets us here

[click] We're gonna step in to renderRootsTransaction

-->

---

<img src="/images/debug-render-break-step-21.png" />

<!-- 

In renderRootsTransaction, the interesting part here is this single method call to renderRoots

-->

---

<div class="image-stack no-border auto">
<img v-after style="max-width: 500px" src="/images/debug-render-break-step-22.png" />
<img v-click style="max-width: 500px" src="/images/debug-render-break-step-22.1.png" />
</div>

<!-- 

And in renderRoots, we have this transaction which calls render 

[click] we'll put a breakpoint there and hit continue so we hit it

-->

---

<div class="image-stack no-border auto">
<img v-after  src="/images/debug-render-break-step-23.png" />
<img v-click  src="/images/debug-render-break-step-23.1.png" />
<img v-click  src="/images/debug-render-break-step-23.2.png" />
</div>

<!-- 

Stepping in to that we land here.

[click] we'll definately want to step in to the render function 

[click] here


-->

---

<img  src="/images/debug-render-break-step-24.png" />

<!-- 

This takes us to our final location for now.

This is the entrypoint of how a renderer is configured for glimmer.

We can probably simplify all this infrastructure over time, and make it easier to understand,
swappable, etc, but for now, this is all we need to know about. 


-->

---
layout: centered
---

<h1 style="font-size: 6rem; line-height: 7rem;"><em>You now know how updates to tracked properties cause renders</em></h1>

<div v-click>ðŸŽ‰</div>


<!-- 

You now know how updates to tracked properties cause renders.


[click] With this knowledge you can do some fun things -- and we'll get there.

-->




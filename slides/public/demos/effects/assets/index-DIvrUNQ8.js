var e={};Object.defineProperty(e,"__esModule",{value:!0});var r=e.ImportUtil=void 0;function t(e,r,t){if(e){let r=e.replace(/[^a-zA-Z_]([a-z])/g,(e,r)=>r.toUpperCase());return r=r.replace(/[^a-zA-Z_]/g,""),r}return"default"===r||"*"===r?null!=t?t:"a":r}function o(e){return(null==e?void 0:e.isIdentifier())?e.node.name:e?e.scope.generateUidIdentifierBasedOnNode(e.node).name:void 0}function i(e,r){switch(r){case"default":return e.isImportDefaultSpecifier();case"*":return e.isImportNamespaceSpecifier();default:return e.isImportSpecifier()&&("StringLiteral"===(t=e.node.imported).type?t.value:t.name)===r}var t}function s(e,r){return e.isImportDeclaration()&&e.get("source").node.value===r}r=e.ImportUtil=class{constructor(e,r){this.babel=e,this.program=r,this.t=e.types}removeImport(e,r){for(let t of this.program.get("body")){if(!s(t,e))continue;let o=t.get("specifiers").find(e=>i(e,r));o&&(1===t.node.specifiers.length?t.remove():o.remove())}}removeAllImports(e){for(let r of this.program.get("body"))s(r,e)&&r.remove()}import(e,r,i,s){return this.unreferencedImport(e,r,i,t(s,i,o(e)))}unreferencedImport(e,r,t,o){var s;let n="*"===t,a=!("default"===t||n),l=this.findImportFrom(r),c=null==l?void 0:l.node.specifiers.find(e=>"ImportNamespaceSpecifier"===e.type);if(!((null==l?void 0:l.node.specifiers.find(e=>"ImportSpecifier"===e.type))&&n||c&&a||c&&n)&&l){let r=l.get("specifiers").find(e=>i(e,t));return r&&"module"===(null===(s=e.scope.getBinding(r.node.local.name))||void 0===s?void 0:s.kind)?this.t.identifier(r.node.local.name):this.addSpecifier(e,l,t,o)}{let i=this.insertAfterExistingImports(this.t.importDeclaration([],this.t.stringLiteral(r)));return this.addSpecifier(e,i,t,o)}}importForSideEffect(e){this.findImportFrom(e)||this.insertAfterExistingImports(this.t.importDeclaration([],this.t.stringLiteral(e)))}replaceWith(e,r){return this.mutate(t=>(e.replaceWith(r(t)),e),o(e))}insertAfter(e,r){return this.mutate(t=>e.insertAfter(r(t))[0],o(e))}insertBefore(e,r){return this.mutate(t=>e.insertBefore(r(t))[0],o(e))}mutate(e,r){let o=new Map;const i=e=>{if(!e.isIdentifier())return;let i=o.get(e.node);if(i){let o=this.unreferencedImport(e,i.moduleSpecifier,i.exportedName,t(i.nameHint,i.exportedName,r));e.replaceWith(o);let s=e.scope.getBinding(o.name);if(!s)throw new Error("bug: this is supposed to never happen");s.reference(e)}};let s=e({import:(e,r,t)=>{let i=this.t.identifier("__babel_import_util_placeholder__");return o.set(i,{moduleSpecifier:e,exportedName:r,nameHint:t}),i}});return i(s),this.babel.traverse(s.node,{ReferencedIdentifier:e=>{i(e)}},s.scope,{},s),s}addSpecifier(e,r,t,o){let i,s=this.t.identifier(function(e,r){let t=r,o=0;for(;e.scope.hasBinding(t);)t=`${r}${o++}`;return t}(e,o)),n=this.buildSpecifier(t,s);return"ImportDefaultSpecifier"===n.type?(r.node.specifiers.unshift(n),i=r.get("specifiers.0")):(r.node.specifiers.push(n),i=r.get("specifiers."+(r.node.specifiers.length-1))),r.scope.registerBinding("module",i),s}buildSpecifier(e,r){switch(e){case"default":return this.t.importDefaultSpecifier(r);case"*":return this.t.importNamespaceSpecifier(r);default:return this.t.importSpecifier(r,this.t.identifier(e))}}findImportFrom(e){for(let r of this.program.get("body"))if(r.isImportDeclaration()&&r.node.source.value===e&&"type"!==r.node.importKind)return r}insertAfterExistingImports(e){let r;for(let[t,o]of this.program.node.body.entries())"ImportDeclaration"===o.type&&(r=t);return null==r?(this.program.node.body.unshift(e),this.program.get("body.0")):(this.program.node.body.splice(r+1,0,e),this.program.get(`body.${r+1}`))}};var n={},a={};Object.defineProperty(a,"__esModule",{value:!0}),a.declare=c,a.declarePreset=void 0;const l={assertVersion:e=>r=>{!function(e,r){if("number"==typeof e){if(!Number.isInteger(e))throw new Error("Expected string or integer value.");e=`^${e}.0.0-0`}if("string"!=typeof e)throw new Error("Expected string or integer value.");const t=Error.stackTraceLimit;let o;throw"number"==typeof t&&t<25&&(Error.stackTraceLimit=25),o="7."===r.slice(0,2)?new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${r}". You'll need to update your @babel/core version.`):new Error(`Requires Babel "${e}", but was loaded with "${r}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`),"number"==typeof t&&(Error.stackTraceLimit=t),Object.assign(o,{code:"BABEL_VERSION_UNSUPPORTED",version:r,range:e})}(r,e.version)}};function c(e){return(r,t,o)=>{var i;let s;for(const e of Object.keys(l))r[e]||(null!=s||(s=d(r)),s[e]=l[e](s));return e(null!=(i=s)?i:r,t||{},o)}}Object.assign(l,{targets:()=>()=>({}),assumption:()=>()=>{}});const p=c;function d(e){let r=null;return"string"==typeof e.version&&/^7\./.test(e.version)&&(r=Object.getPrototypeOf(e),!r||u(r,"version")&&u(r,"transform")&&u(r,"template")&&u(r,"types")||(r=null)),Object.assign({},r,e)}function u(e,r){return Object.prototype.hasOwnProperty.call(e,r)}a.declarePreset=p,Object.defineProperty(n,"__esModule",{value:!0});var f=n.default=void 0,h=a;function m(e){const t=e.types;return{Program(o,i){i.currentClassBodies=[],i.currentObjectExpressions=[],i.optsWithDefaults={runtime:"globals",runEarly:!1,...i.opts},i.util=new r(e,o),i.runtime=(e,r)=>{const{runtime:o}=i.optsWithDefaults;return"globals"===o?t.memberExpression(t.identifier("dt7948"),t.identifier(r)):e.import(o.import,r)}},ClassBody:{enter(e,r){r.currentClassBodies.unshift(e.node)},exit(e,r){r.currentClassBodies[0]===e.node&&r.currentClassBodies.shift()}},ClassExpression(e,r){let o=e.get("decorators");Array.isArray(o)&&o.length>0&&r.util.replaceWith(e,i=>{let s=t.callExpression(r.runtime(i,"c"),[e.node,t.arrayExpression(o.slice().reverse().map(e=>e.node.expression))]);for(let e of o)e.remove();return s})},ClassDeclaration(e,r){let o=e.get("decorators");if(Array.isArray(o)&&o.length>0){const i=i=>t.callExpression(r.runtime(i,"c"),[t.classExpression(e.node.id,e.node.superClass,e.node.body,[]),t.arrayExpression(o.slice().reverse().map(e=>e.node.expression))]);if(e.parentPath.isExportDefaultDeclaration()){let o=e.node.id;o?(r.util.insertBefore(e.parentPath,e=>t.variableDeclaration("const",[t.variableDeclarator(o,i(e))])),e.parentPath.replaceWith(t.exportDefaultDeclaration(o))):r.util.replaceWith(e.parentPath,e=>t.exportDefaultDeclaration(i(e)))}else if(e.parentPath.isExportNamedDeclaration()){let o=e.node.id;if(!o)throw new Error("bug: expected a class name is required in this context");r.util.insertBefore(e.parentPath,e=>t.variableDeclaration("const",[t.variableDeclarator(o,i(e))])),e.parentPath.replaceWith(t.exportNamedDeclaration(null,[t.exportSpecifier(o,o)]))}else{let o=e.node.id;if(!o)throw new Error("bug: expected a class name is required in this context");r.util.replaceWith(e,e=>t.variableDeclaration("const",[t.variableDeclarator(o,i(e))]))}}},ClassProperty(e,r){let o=e.get("decorators");if(Array.isArray(o)&&o.length>0){let i;i=e.node.static?t.thisExpression():t.memberExpression(t.thisExpression(),t.identifier("prototype"));let s=[i,y(t,e.node.key),t.arrayExpression(o.slice().reverse().map(e=>e.node.expression))];e.node.value&&s.push(t.functionExpression(null,[],t.blockStatement([t.returnStatement(e.node.value)]))),r.util.insertBefore(e,e=>t.staticBlock([t.expressionStatement(t.callExpression(r.runtime(e,"g"),s))])),r.util.insertBefore(e,o=>{return t.classPrivateProperty(t.privateName(t.identifier(function(e,r){let t=e.currentClassBodies[0];if(!t)throw new Error("bug: no current class body around our class field decorator");let o=new Set;for(let s of t.body)"ClassPrivateProperty"!==s.type&&"ClassPrivateMethod"!==s.type&&"ClassAccessorProperty"!==s.type||"PrivateName"!==s.key.type||o.add(s.key.id.name);let i=r;for(;o.has(i);)i+="_";return i}(r,"Identifier"===(i=e.node.key).type?i.name:"BigIntLiteral"===i.type||"NumericLiteral"===i.type?`_${i.value}`:"StringLiteral"===i.type?"_"+i.value.replace(/[^a-zA-Z]/g,""):"_"))),t.sequenceExpression([t.callExpression(r.runtime(o,"i"),[t.thisExpression(),y(t,e.node.key)]),t.identifier("void 0")]));var i}),e.remove()}},ClassMethod(e,r){let o=e.get("decorators");if(Array.isArray(o)&&o.length>0){let i;i=e.node.static?t.thisExpression():t.memberExpression(t.thisExpression(),t.identifier("prototype")),r.util.insertAfter(e,s=>t.staticBlock([t.expressionStatement(t.callExpression(r.runtime(s,"n"),[i,y(t,e.node.key),t.arrayExpression(o.slice().reverse().map(e=>e.node.expression))]))]));for(let e of o)e.remove()}},ObjectExpression:{enter(e,r){r.currentObjectExpressions.unshift({node:e.node,decorated:[]})},exit(e,r){var o;if((null==(o=r.currentObjectExpressions[0])?void 0:o.node)!==e.node)return;let{decorated:i}=r.currentObjectExpressions.shift();i.length>0&&r.util.replaceWith(e,o=>t.callExpression(r.runtime(o,"p"),[e.node,t.arrayExpression(i.map(([e,r,o])=>t.arrayExpression([t.stringLiteral(e),r,t.arrayExpression(o)])))]))}},ObjectProperty(e,r){let o=e.get("decorators");if(Array.isArray(o)&&o.length>0){if(0===r.currentObjectExpressions.length)throw new Error("bug in decorator-transforms: didn't expect to see ObjectProperty outside ObjectExpression");let i=e.node.key;if("PrivateName"===i.type)throw new Error("cannot decorate private field");r.currentObjectExpressions[0].decorated.push(["field",y(t,i),o.slice().reverse().map(e=>e.node.expression)]);for(let e of o)e.remove()}},ObjectMethod(e,r){let o=e.get("decorators");if(Array.isArray(o)&&o.length>0){if(0===r.currentObjectExpressions.length)throw new Error("bug in decorator-transforms: didn't expect to see ObjectMethod outside ObjectExpression");let i=e.node.key;r.currentObjectExpressions[0].decorated.push(["method",y(t,i),o.slice().reverse().map(e=>e.node.expression)]);for(let e of o)e.remove()}}}}function g(e){let r=m(e);return{inherits:(e,r,t)=>f(e,{legacy:!0},t),pre(t){this.opts.runEarly&&(e.traverse(t.ast,m(e),t.scope,this),r=void 0)},get visitor(){return r??{}}}}function y(e,r){return"Identifier"===r.type?e.stringLiteral(r.name):r}f=n.default=(0,h.declare)((e,r)=>{e.assertVersion(7);let{version:t}=r;{const{legacy:e}=r;if(void 0!==e){if("boolean"!=typeof e)throw new Error(".legacy must be a boolean.");if(void 0!==t)throw new Error("You can either use the .legacy or the .version option, not both.")}if(void 0===t)t=e?"legacy":"2018-09";else if("2023-05"!==t&&"2023-01"!==t&&"2022-03"!==t&&"2021-12"!==t&&"2018-09"!==t&&"legacy"!==t)throw new Error("Unsupported decorators version: "+t);var{decoratorsBeforeExport:o}=r;if(void 0===o){if("2021-12"===t||"2022-03"===t)o=!1;else if("2018-09"===t)throw new Error("The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.")}else{if("legacy"===t||"2022-03"===t||"2023-01"===t)throw new Error(`'decoratorsBeforeExport' can't be used with ${t} decorators.`);if("boolean"!=typeof o)throw new Error("'decoratorsBeforeExport' must be a boolean.")}}return{name:"syntax-decorators",manipulateOptions({generatorOpts:e},r){"legacy"===t?r.plugins.push("decorators-legacy"):"2023-01"===t||"2023-05"===t?r.plugins.push(["decorators",{allowCallParenthesized:!1}],"decoratorAutoAccessors"):"2022-03"===t?r.plugins.push(["decorators",{decoratorsBeforeExport:!1,allowCallParenthesized:!1}],"decoratorAutoAccessors"):"2021-12"===t?(r.plugins.push(["decorators",{decoratorsBeforeExport:o}],"decoratorAutoAccessors"),e.decoratorsBeforeExport=o):"2018-09"===t&&(r.plugins.push(["decorators",{decoratorsBeforeExport:o}]),e.decoratorsBeforeExport=o)}}});export{g as default};
